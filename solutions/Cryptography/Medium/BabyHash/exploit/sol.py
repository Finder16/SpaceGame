from pwn import *
from itertools import product
from tqdm import *
from multiprocessing import Pool
import hashlib
import time

BSIZE = 26
L = 286
def pad(s):
    padlen = BSIZE-len(s)%BSIZE
    return s+bytes([padlen])*padlen

def query(r,s):
    if isinstance(s,str):
        s = s.encode()
    r.sendlineafter(b">>> ",s)
    r.recvuntil(b"Nonce = ")
    nonce = bytes.fromhex(r.recvline().strip().decode())
    r.recvuntil(b"Output = ")
    out = bytes.fromhex(r.recvline().strip().decode())
    return nonce,out

def send_answer(r,answer):
    if isinstance(answer,str):
        answer = answer.encode()
    r.sendlineafter(b">>> ",b"Yo Bro I got the answer")
    r.sendlineafter(b"Answer >>> ",answer)

def h(nonce,msg):
    if isinstance(msg,str):
        msg = msg.encode()
    return hashlib.sha256(msg+nonce).digest()

#r = process(["python3","prob.py"])
r = remote('localhost', 1971)

charset = "0123456789abcdef"
# Get count of each letter
cnt = [None]*16
for i,c in enumerate(charset):
    nonce,out = query(r,charset.replace(c,""))
    out_len = len(out)
    bcnt = out_len//32-1
    rainbow = [h(nonce,pad(c.encode()*j)[:BSIZE])for j in range(BSIZE+1)]
    cnt[i] = 0
    for j in range(bcnt):
        assert out[32*j:32*j+32] == rainbow[BSIZE]
        cnt[i] += BSIZE
    idx = rainbow.index(out[-32:])
    cnt[i] += idx
print(f"{cnt = }")
assert sum(cnt) == 2*L

l = []
for i in range(16):
    c1 = charset[i]
    for j in range(i+1,16):
        c2 = charset[j]
        nonce,out = query(r,charset.replace(c1,"").replace(c2,""))
        l.append((i,j,c1,c2,nonce,out))

def worker(idx):
    global l
    qr = {}
    for _ in trange(120//8):
        i,j,c1,c2,nonce,out = l[idx*120//8+_]
        ccnt = cnt[i]+cnt[j]
        out_len = len(out)
        # full rainbow
        blks = [out[k:k+32]for k in range(0,out_len,32)]
        revs = [None]*len(blks)
        for s in product(c1+c2,repeat=ccnt%BSIZE):
            ss = pad(''.join(s).encode())
            hsh = h(nonce,ss)
            if blks[-1] == hsh:
                revs[-1] = ''.join(s)
        for s in product(c1+c2,repeat=BSIZE):
            s = ''.join(s)
            hsh = h(nonce,s)
            for k in range(len(blks)):
                if blks[k] == hsh:
                    revs[k] = s
        rev = ''.join(revs)[:ccnt]
        qr[(i,j)] = rev
    return qr
context.log_level = 'debug'
with Pool(8) as pool:
    _ = pool.map_async(worker,range(8))
    while not _.ready():
        sleep(5)
        query(r,"")
    pool.close()
    pool.join()
    _ = _.get()
    qr = {}
    while len(_)>0:
        qr |= _.pop(0)

message = ""
for _ in range(2*L):
    for i,c in enumerate(charset):
        dat = [qr[tuple(sorted([i,j]))][0]==c for j in range(16) if i!=j and len(qr[tuple(sorted([i,j]))])>0]
        if len(dat)>0 and all(dat):
            message += c
            for j in range(16):
                if i==j or len(qr[tuple(sorted([i,j]))])==0:
                    continue
                qr[tuple(sorted([i,j]))] = qr[tuple(sorted([i,j]))][1:]
            break
print(message)
context.log_level='debug'
send_answer(r,message)
r.interactive()
