# permutation

#### 출제자 : 조수호 / shielder

## Concept

- determinant

## Writeup

각 함수를 분석하겠습니다.
`main` : `init`, `f1` 실행 후 `ans`를 출력합니다.
`init` : 기초 세팅 함수입니다.
`f1` : 어떤 치환을 생성하고 `f2`를 호출합니다. 이 치환은 `S_20`의 원소이며, `S_20`의 모든 원소를 탐색합니다.
`f2` : 치환의 첫 숫자가 기존과 달라질 때마다 1~19의 범위에서 서로 다른 랜덤한 두 숫자를 고르고, 이 두 숫자 쌍과 두 숫자에서 각각 1씩 더한 숫자 쌍을 테이블에 저장합니다. `f3`를 호출합니다.
`f3` : 현재 치환의 `Inversion`의 총 개수를 계산합니다. 이것이 짝수 개이면 `f4(1)`을, 홀수 개이면 `f4(-1)`을 호출합니다.
`f4` : `f2`에서 저장했던 숫자 쌍들을 호환으로 생각하여 현재 치환에 합성합니다. 그 후 각 열에서 최종 치환의 행 번호에 해당하는 수를 가져와 모두 곱합니다. `f4(1)`로 호출되었다면 `ans`에 그 값을 더하고, `f4(-1)`로 호출되었다면 `ans`에 그 값을 뺍니다.

`a2` 테이블의 호환 합성을 제외하면 `f4` 함수의 동작은 행렬식 계산과 일치합니다. (AI가 문제를 바로 푸는 것을 방지하기 위해 `a2` 테이블로 랜덤 호환을 추가하였습니다. 행렬식과 비슷한 과정임은 언급할 수 있어도 완벽히 같은 과정임을 증명하는 것은 어려울 것으로 예상합니다.) 이제 이 프로그램이 `a2` 테이블의 호환 합성이나 그 외 요소의 작용에도 행렬식 계산과 같은지를 생각해보겠습니다.

1. `a2` 테이블의 호환이 적용되어도 `S_20`의 원소가 모두 한 번씩 탐색되는가?
`a2`가 `1~19`만 저장합니다. 그리고 `a2` 테이블에 숫자 쌍이 추가되는 것은 `a1[0]`의 값이 바뀔 때입니다. 따라서 `a1[0]` 값이 같은 치환에 적용되는 호환은 같고, `a1[0]`는 바뀌지 않습니다. 따라서 `a1[0]`가 고정된 상태에서 한 호환이 합성되는 상태를 생각해도 됩니다. 이 경우 1번 치환이 호환과 합성하여 2번 치환이 되는데, 2번 치환이 호환과 합성하면 1번 치환이 되므로 두 치환을 쌍으로 생각할 수 있습니다. 이러한 논리로 모든 치환을 쌍을 지을 수 있고, `a1[0]`가 고정되었을 때 탐색되는 치환은 한 호환이 합성되어도 같음을 알 수 있습니다. 귀납적 사고를 통해 호환이 몇 개가 합성되어도 탐색되는 치환은 같습니다. 모든 `a1[0]`에 대해 성립하므로 `a2` 테이블의 호환의 적용되어도 `S_20`의 원소가 모두 한 번씩 탐색됩니다.

2. 부호(`sgn`)가 변하지 않는가?
`f2`에서 `a2` 테이블에 숫자 쌍을 넣을 때 두 개의 쌍을 넣습니다. 치환의 부호는 호환 하나가 합성될 때마다 변하므로 호환이 두 개 합성되면 부호가 변하지 않습니다.

3. 오버플로우/언더플로우에 의한 오류는 없는가?
프로그램에서 `k`로 저장된 수는 `(2^64) * a + k (a는 임의의 정수)`입니다. 따라서 `res`가 다 더해진 `ans` 또한 `(2^64) * b + l (b는 임의의 정수)`이고, `l`로 저장됩니다. 그런데 프로그램의 행렬의 행렬식은 `2^64`보다 작기 때문에 `b = 0`입니다. 따라서 오류는 없습니다. 

위와 같이 프로그램이 행렬식 계산임을 증명할 수 있습니다. `n = 20`으로 설정하였으므로 프로그램은 20 by 20 행렬의 행렬식 계산을 하고 있습니다. 하지만 그 알고리즘이 최적화되어있지 않아 `상수 곱 * 20!` 만큼의 연산을 수행해야 합니다. 그래서 프로그램의 결과가 출력되지 않는 것입니다. 따라서 `python`에서 행렬을 가져와 `sage`로 행렬식을 계산하여 `flag.py`의 형식에 맞춰 넣으면 됩니다.

## ex.py

```python
from sage.all import *
from pwn import *

e = ELF('./main')
dt = e.read(0x4080, 8 * 20 * 20)
arr = [int.from_bytes(dt[i:i+8], 'little') for i in range(0, 8 * 20 * 20, 8)]

m1 = zero_matrix(ZZ, 20)
for i in range(20):
    for j in range(20):
        m1[i, j] = arr[20 * i + j]

output = m1.det()
print("hspace{" + bytes.fromhex(hex(output)[2:]).decode() + "}")
```