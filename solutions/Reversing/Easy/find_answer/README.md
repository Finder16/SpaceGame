# Find Answer

# Usage

# Concept
- binary patch
- aria

# Writeup
프로그램을 실행시키면 입력하는 부분이 나오게 된다. Y나 N을 입력하게 되면 잘못된 플래그가 출력되거나 바로 프로그램이 종료됩니다.
이를 넘어서 정답에 근접하기 위해서 디컴파일된 결과를 확인해 보면, 입력이 들어오고나서 strncmp함수를 통해 bug_hunt라는 문자열과 동일한지 확인을 하게됩니다. 
그러고 나면 또다른 입력하는 부분이 나오게 됩니다. 이부분에서 특정 역할을 하는 입력값은 3개인것을 알 수 있습니다.
우선 바로 알 수 있는 입력값은 `aria`입니다. 이 입력값을 넣게 되면 아래와 같은 .aria 파일이 생성됩니다. 안의 내용을 확인하면 아래와 같습니다.
```
openssl
aria-128-cbc
pw: welcome
```
이 내용을 통해서 알 수 있는 내용은 `openssl`의 `aria-128-cbc`를 이용해서 복호화 하면 되고, 비밀번호가 `welcome`이라는 것을 알 수 있습니다.
`openssl enc -aria-128-cbc -d -in {input file path} -out {output file path}`의 명령어를 이용해서 주어진 flag.txt파일을 복호화 해줍니다.

이후 다시 디컴파일 내용을 확인해 보면 입력값을 `hunting_master`라는 문자열과의 xor 연산 후 어떤 문자열과 비교하는 것을 알 수 있습니다.
이후 이 값을 비교해서 만약 리턴값이 0이 아니면 잘못된 값을 출력해 주게 되고, 0이면 플래그와 관련된 값을 출력하게 됩니다.
입력하기 위한 값은 


```C
char arr[] = { 0x3f, 0x41, 0x00, 0x00, 0x36, 0x1a, 0x08, 0x00, 0x07, 0x0e, 0x42, 0x1a, 0x3a, 0x1a, 0x1d, 0x1b, 0x59, 0x1d, 0x07, 0x57, 0x38, 0x32, 0x59, 0x12, 0x07, 0x47, 0x17, 0x2d, 0x0b, 0x19, 0x5a, 0x07, 0x1a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
char xor[] = "hunting_master";
int j = 0;

for(int i = 0; i < 0xf; i++){
    arr[i] ^= xor[j];
    j++;
}
```
코드를 통해 `W4nt_to_jo1n_hun7in9_m4st3r_cl4ss?`를 입력하면 된다는 사실을 알 수 있습니다.

이제 다시 실행해서 위에서 얻은 값들을 입력해 주면 프로세스가 시작하고 종료한다는 내용이 출력되는데 순서가 맞지 않다는 것을 통해서 실행되는 함수의 순서가 잘못되었다는 것을 알 수 있습니다.
이를 통해서 두 함수의 순서를 바이너리 패치를 통해서 바꾸어 주면 된다는 것을 알 수 있습니다.

바이너리 패치까지 마무리하고 나면 위에서 얻은 결과값들을 다시 입력해주면 아래와 같은 플래그를 얻을 수 있습니다.
`huntingmaster{vrwX9Tx&y*e8'aYdq&$'t$(kCN6<TI)@gxj5&Esddq.b2}`