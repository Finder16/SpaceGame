from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import binascii
context.log_level = "debug"

# Constants
BINARY_STRINGS = {
    'one_32': b"1" * 128,
    'zero_32': b"0" * 128,
    'one_zero_16': b"10" * 64,
    'zero_one_16': b"01" * 64
}

r = remote("pwnable.co.kr", 5678)

# Helper Functions
def encrypt_aes_ecb(hex_data, hex_key):
    key = binascii.unhexlify(hex_key)
    data = binascii.unhexlify(hex_data)
    cipher = AES.new(key, AES.MODE_ECB)
    padded_data = pad(data, AES.block_size)
    return binascii.hexlify(cipher.encrypt(padded_data)).decode('utf-8')

def get_mode():
    r.recv()
    r.sendline(b"1")
    r.recvuntil(b"Mode : ")
    mode = r.recv(1)
    log.info(f"[+] Current mode: {mode}")
    r.recv()
    return mode

def set_mode(mode):
    if mode in [b"1", b"2"]:
        value = BINARY_STRINGS['zero_one_16']
    elif mode in [b"3", b"4"]:
        value = BINARY_STRINGS['one_zero_16']
    else:
        return

    r.sendline(b"3")
    r.recv()
    r.sendline(b"3")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value)
    r.recv()
    log.info("[+] Set sck")

def get_aes_key_part(part_idx, value_4, value_5, value_6=None):
    r.sendline(b"3")
    r.recv()
    r.sendline(b"4")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value_4)
    r.recv()
    r.sendline(b"3")
    r.recv()
    r.sendline(b"5")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value_5)
    r.recv()
    if value_6:
        r.sendline(b"3")
        r.recv()
        r.sendline(b"6")
        r.recvuntil(b"Enter new value (binary string): \n")
        r.sendline(value_6)
        r.recv()
    r.sendline(b"2")
    r.sendline(b"1")
    r.recvuntil(b"Master MISO: ")
    key_part = r.recv(32)
    log.info(f"Part {part_idx} of key: {key_part}")
    r.recv()
    return key_part

def hex_to_4byte_bin(send_data):
    return ''.join(f'{int(send_data[i], 16):04b}' for i in range(32))

def set_slave_miso(slave_idx, original_data, key, value_4, value_5, value_6):
    enc_data = encrypt_aes_ecb(original_data, key)
    r.sendline(b"3")
    r.recv()
    r.sendline(b"1")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(hex_to_4byte_bin(enc_data)[:128].encode('utf-8'))
    r.recv()
    log.info(f"Set Master's MOSI: {enc_data[:32]}")

    r.sendline(b"3")
    r.recv()
    r.sendline(b"4")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value_4)
    r.recv()
    r.sendline(b"3")
    r.recv()
    r.sendline(b"5")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value_5)
    r.recv()
    r.sendline(b"3")
    r.recv()
    r.sendline(b"6")
    r.recvuntil(b"Enter new value (binary string): \n")
    r.sendline(value_6)
    r.recv()
    r.sendline(b"2")
    log.info(f"Set Slave{slave_idx}'s MOSI: {enc_data[:32]}")
    log.info(f"Set Slave{slave_idx}'s MISO: {original_data[:32]}")
    r.recv()

def get_flag():
    r.sendline(b"4")

# Main Logic
mode = get_mode()
set_mode(mode)

first_key = get_aes_key_part(1, BINARY_STRINGS['one_32'], BINARY_STRINGS['zero_32'], BINARY_STRINGS['zero_32'])
second_key = get_aes_key_part(2, BINARY_STRINGS['zero_32'], BINARY_STRINGS['one_32'])
third_key = get_aes_key_part(3, BINARY_STRINGS['zero_32'], BINARY_STRINGS['zero_32'], BINARY_STRINGS['one_32'])

key = first_key + third_key
log.info(f"AES Key: {key}")

set_slave_miso("A", "12FF56FF90FF34FF78FF12FF56FF90FF", key, BINARY_STRINGS['one_32'], BINARY_STRINGS['zero_32'], BINARY_STRINGS['zero_32'])
set_slave_miso("B", "FF34FF78FF12FF56FF90FF34FF78FF12", key, BINARY_STRINGS['zero_32'], BINARY_STRINGS['one_32'], BINARY_STRINGS['zero_32'])
set_slave_miso("C", "edcba9876fedcba9876fedcba9876fed", key, BINARY_STRINGS['zero_32'], BINARY_STRINGS['zero_32'], BINARY_STRINGS['one_32'])

get_flag()
r.interactive()